<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TTDB Viewer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Unbounded:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="css/tte-common.css" />
  <style>
    .page {
      max-width: 1280px;
      margin: 0 auto;
      padding: 32px clamp(18px, 4vw, 48px) 48px;
      display: grid;
      gap: 20px;
      position: relative;
      z-index: 1;
    }

    header {
      display: grid;
      grid-template-columns: minmax(320px, 1.1fr) minmax(280px, 1fr);
      align-items: stretch;
      gap: 18px;
      padding: 18px 22px;
      border-radius: 18px;
      background: rgba(192, 232, 207, 0.88);
      border: 1px solid rgba(11, 17, 18, 0.12);
      box-shadow: 0 18px 36px rgba(11, 17, 18, 0.18);
    }

    .header-left {
      display: grid;
      gap: 14px;
      align-content: start;
    }

    .header-right {
      display: grid;
      align-content: stretch;
    }

    .home-link {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(192, 232, 207, 0.92);
      color: var(--ink);
      font-size: 14px;
      text-decoration: none;
      box-shadow: 0 10px 24px rgba(11, 17, 18, 0.18);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }

    .home-link:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0 14px var(--glow);
    }

    .title {
      display: grid;
      gap: 6px;
    }

    .title h1 {
      margin: 0;
      font-family: "Unbounded", "Space Grotesk", sans-serif;
      font-size: clamp(26px, 4vw, 38px);
      letter-spacing: 0.5px;
    }

    .title span {
      color: var(--muted);
      font-size: 14px;
    }

    .title a {
      color: var(--accent);
      text-decoration: none;
    }

    .title a:hover {
      text-decoration: underline;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }

    .pill {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-2);
      color: var(--ink);
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .pill:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--glow);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-2);
      font-size: 14px;
      color: var(--ink);
    }

    .toggle input {
      accent-color: var(--accent);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(200px, 0.75fr) minmax(280px, 2fr);
      gap: 20px;
      min-height: 70vh;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 16px 36px rgba(11, 17, 18, 0.14);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-content: start;
      height: 100%;
    }

    .list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
      overflow: auto;
      align-content: start;
      flex: 1;
      min-height: 0;
    }

    .list button {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: var(--panel-2);
      color: var(--ink);
      font-family: inherit;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .list button:hover {
      border-color: rgba(124, 199, 255, 0.4);
    }

    .list button.active {
      border-color: var(--accent);
      background: rgba(15, 139, 141, 0.12);
      box-shadow: inset 0 0 0 1px rgba(15, 139, 141, 0.2);
    }

    .record {
      display: grid;
      gap: 14px;
      min-height: 240px;
      overflow: auto;
      padding-right: 6px;
      flex: 1;
      min-height: 0;
    }

    .record h2,
    .record h3,
    .record h4 {
      margin: 0;
      font-family: "Unbounded", "Space Grotesk", sans-serif;
    }

    .record h2 {
      color: var(--title);
      font-size: 22px;
    }

    .record h3 {
      color: var(--teal);
      font-size: 18px;
    }

    .record .record-title {
      color: var(--eyeball-red);
    }

    .record h4 {
      color: var(--eyeball-red);
      font-size: 16px;
    }

    .record p {
      margin: 0;
      line-height: 1.6;
      color: var(--ink);
    }

    .record ul {
      margin: 0;
      padding-left: 18px;
    }

    .record blockquote {
      margin: 0;
      padding: 8px 12px;
      border-left: 3px solid rgba(15, 139, 141, 0.45);
      color: var(--muted);
      background: rgba(11, 17, 18, 0.08);
    }

    .record pre {
      margin: 0;
      padding: 12px;
      background: #0b0f14;
      border-radius: 12px;
      color: #c4f1ff;
      font-family: "Courier New", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
      overflow: auto;
    }

    .record img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 10px;
    }

    .record .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .record .related a {
      color: var(--accent);
      text-decoration: none;
    }

    .record .related a:hover {
      text-decoration: underline;
    }

    .graph-wrap {
      background: rgba(11, 17, 18, 0.08);
      border-radius: 14px;
      border: 1px solid var(--line);
      min-height: 220px;
      position: relative;
    }

    .header-graph {
      height: 100%;
      min-height: 240px;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    @media (max-width: 920px) {
      header {
        grid-template-columns: 1fr;
      }

      .layout {
        grid-template-columns: 1fr;
        min-height: auto;
      }

      .record {
        height: auto;
        flex: none;
      }

      .list {
        height: auto;
        max-height: 40vh;
        flex: none;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <a class="home-link" href="index.html">TTE Home</a>
    <header>
      <div class="header-left">
        <div class="title">
          <h1>TTDB: MyMentalPalace</h1>
          <p>A single-file semantic story database. It stores records as <a href="https://github.com/antfriend/toot-toot-engineering/blob/main/RFCs/TTDB-RFC-0001-File-Format.md">markdown nodes in a network graph</a> of semantic links. The ID of each record is a latitudinal and longitudinal point on a knowledge globe, defined by the <a href="https://github.com/antfriend/toot-toot-engineering/blob/main/standards/ttai/TTAI_SPEC.md">librarian's</a> <a href="https://github.com/antfriend/toot-toot-engineering/blob/main/standards/umwelt/TTE_Agent_Umwelt_v1.yaml">umwelt.</a></p>

          <p>This web page has no react, packages, or libraries üõçÔ∏è because only foundation level HTML, javascript, and CSS are necessary to parse and render TTDB record and relationship data. It also can be rendered as <a href="graph-view.html">a one-page d3 app.</a></p>

          <p>TTDB has <a href="https://github.com/antfriend/toot-toot-engineering/blob/main/standards/ttai/BEHAVIOR_SPEC.md#primitive-mode-constraints">a default network</a> for defining autonomous behavior of micro-scale (esp32/Arduino) devices within the semantic globe of their point of view. Recording sensor data, listening for birds, defending territory kinds-of-things when they have free time. Specifically <a href="https://meshtastic.org/">Meshtastic</a> devices.</p>
          <span id="status">Loading MyMentalPalaceDB.md...</span>
        </div>
        <div class="controls">
          <button class="pill" id="refresh">Refresh</button>
          <label class="toggle">
            <input type="checkbox" id="autoRefresh" checked />
            Auto refresh
          </label>
        </div>
      </div>
      <div class="header-right">
        <div class="graph-wrap header-graph">
          <canvas id="graph"></canvas>
        </div>
      </div>
    </header>

    <div class="layout">
      <section class="panel">
        <strong>Records</strong>
        <ul class="list" id="recordList"></ul>
      </section>

      <section class="panel">
        <div class="record" id="recordView"></div>
      </section>
    </div>
  </div>

  <script>
    const DB_PATH = "MyMentalPalaceDB.md";
    const REFRESH_MS = 1500;

    const state = {
      records: {},
      order: [],
      selectedId: null,
      lastText: "",
      positions: {},
    };

    const palette = (() => {
      const styles = getComputedStyle(document.documentElement);
      const read = (name, fallback) => styles.getPropertyValue(name).trim() || fallback;
      return {
        accent: read("--accent", "#0f8b8d"),
        accentAlt: read("--accent-2", "#e76f51"),
        ink: read("--ink", "#0b1112"),
        muted: read("--muted", "rgba(11, 17, 18, 0.6)"),
        line: read("--line", "rgba(11, 17, 18, 0.2)"),
      };
    })();

    const statusEl = document.getElementById("status");
    const listEl = document.getElementById("recordList");
    const viewEl = document.getElementById("recordView");
    const graphCanvas = document.getElementById("graph");
    const refreshBtn = document.getElementById("refresh");
    const autoRefresh = document.getElementById("autoRefresh");

    const ctx = graphCanvas.getContext("2d");
    const resizeObserver = new ResizeObserver(() => renderGraph());
    resizeObserver.observe(graphCanvas.parentElement);

    refreshBtn.addEventListener("click", () => loadDb(true));

    function setStatusMessage(message) {
      statusEl.textContent = message;
    }

    function setStatusLink(recordCount) {
      statusEl.innerHTML = `DB: <a href="${DB_PATH}">${DB_PATH}</a> ¬∑ ${recordCount} records`;
    }

    function sanitize(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    function loadDb(force = false) {
      fetch(DB_PATH, { cache: "no-store" })
        .then((res) => {
          if (!res.ok) throw new Error(`Failed to load ${DB_PATH}`);
          return res.text();
        })
        .then((text) => {
          if (!force && text === state.lastText) return;
          state.lastText = text;
          const { records, order, selected } = parseRecords(text);
          state.records = records;
          state.order = order;
          if (!state.selectedId || !records[state.selectedId]) {
            state.selectedId = selected || order[0] || null;
          }
          renderList();
          renderRecord();
          renderGraph();
          setStatusLink(order.length);
        })
        .catch((err) => {
          setStatusMessage(err.message);
          state.records = {};
          state.order = [];
          state.selectedId = null;
          renderList();
          renderRecord();
          renderGraph();
        });
    }

    function parseRecords(content) {
      let selected = null;
      const cursorMatch = content.match(/```cursor([\s\S]*?)```/);
      if (cursorMatch) {
        const lines = cursorMatch[1].split(/\r?\n/);
        let inSelected = false;
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith("selected:")) {
            inSelected = true;
            continue;
          }
          if (inSelected) {
            const itemMatch = trimmed.match(/^-\s*(\S+)/);
            if (itemMatch) {
              selected = itemMatch[1];
              break;
            }
            if (trimmed && !trimmed.startsWith("-")) {
              break;
            }
          }
        }
      }

      const records = {};
      const order = [];
      const blocks = content.split(/^\s*---+\s*$/m);
      for (const block of blocks) {
        const lines = block.split(/\r?\n/);
        let headerIndex = -1;
        for (let i = 0; i < lines.length; i += 1) {
          if (lines[i].startsWith("@")) {
            headerIndex = i;
            break;
          }
        }
        if (headerIndex < 0) continue;
        const headerLine = lines[headerIndex].trim();
        const recordId = headerLine.split(/\s+/)[0];
        const bodyLines = lines.slice(headerIndex + 1);
        let title = null;
        let titleRemoved = false;
        const filteredBodyLines = [];
        for (const line of bodyLines) {
          const match = line.match(/^##\s+(.*)$/);
          if (match && !titleRemoved) {
            title = match[1].trim();
            titleRemoved = true;
            continue;
          }
          filteredBodyLines.push(line);
        }
        const body = filteredBodyLines.join("\n").trim();

        const edges = [];
        const relatesMatch = headerLine.match(/relates:([^|]+)/);
        if (relatesMatch) {
          const tokens = relatesMatch[1].split(",");
          for (const tokenRaw of tokens) {
            const token = tokenRaw.trim();
            if (!token) continue;
            let edgeType = "relates";
            let target = token;
            if (token.includes(">")) {
              const [left, right] = token.split(">", 2);
              edgeType = left.trim();
              target = right.trim();
            }
            edges.push({ type: edgeType, target });
          }
        }

        records[recordId] = { header: headerLine, body, title, edges };
        order.push(recordId);
      }

      return { records, order, selected };
    }

    function renderList() {
      listEl.innerHTML = "";
      if (!state.order.length) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "No records available.";
        listEl.appendChild(empty);
        return;
      }

      state.order.forEach((recordId) => {
        const title = state.records[recordId]?.title;
        const label = title ? `${recordId} - ${title}` : recordId;
        const li = document.createElement("li");
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = label;
        if (recordId === state.selectedId) {
          button.classList.add("active");
        }
        button.addEventListener("click", () => selectRecord(recordId));
        li.appendChild(button);
        listEl.appendChild(li);
      });
    }

    function selectRecord(recordId) {
      if (!state.records[recordId]) return;
      state.selectedId = recordId;
      renderList();
      renderRecord();
      renderGraph();
    }

    function renderRecord() {
      viewEl.innerHTML = "";
      if (!state.selectedId || !state.records[state.selectedId]) {
        viewEl.textContent = "No record selected.";
        return;
      }

      const record = state.records[state.selectedId];
      const header = document.createElement("h2");
      header.textContent = state.selectedId;
      viewEl.appendChild(header);

      if (record.title) {
        const title = document.createElement("h3");
        title.className = "record-title";
        title.textContent = record.title;
        viewEl.appendChild(title);
      }

      const meta = document.createElement("div");
      meta.className = "muted";
      meta.textContent = record.header;
      viewEl.appendChild(meta);

      if (record.edges.length) {
        const relatedTitle = document.createElement("h3");
        relatedTitle.textContent = "Related records";
        viewEl.appendChild(relatedTitle);

        const list = document.createElement("ul");
        list.className = "related";
        record.edges.forEach((edge) => {
          const item = document.createElement("li");
          const label = document.createElement("span");
          label.textContent = `${edge.type} -> `;
          item.appendChild(label);
          if (state.records[edge.target]) {
            const link = document.createElement("a");
            link.href = "#";
            link.textContent = edge.target;
            link.addEventListener("click", (event) => {
              event.preventDefault();
              selectRecord(edge.target);
            });
            item.appendChild(link);
          } else {
            const missing = document.createElement("span");
            missing.className = "muted";
            missing.textContent = edge.target;
            item.appendChild(missing);
          }
          list.appendChild(item);
        });
        viewEl.appendChild(list);
      }

      if (record.body) {
        viewEl.appendChild(renderMarkdown(record.body));
      }
    }

    function renderMarkdown(text) {
      const fragment = document.createDocumentFragment();
      const lines = text.split(/\r?\n/);
      const references = {};
      const contentLines = [];
      const refPattern = /^\s*\[([^\]]+)\]:\s*(\S+)(?:\s+"([^"]+)")?\s*$/;
      let inRefCode = false;
      lines.forEach((rawLine) => {
        const trimmed = rawLine.trim();
        if (trimmed.startsWith("```")) {
          inRefCode = !inRefCode;
          contentLines.push(rawLine);
          return;
        }
        if (inRefCode) {
          contentLines.push(rawLine);
          return;
        }
        const match = rawLine.match(refPattern);
        if (match) {
          references[match[1].trim().toLowerCase()] = {
            href: match[2],
            title: match[3] || "",
          };
          return;
        }
        contentLines.push(rawLine);
      });
      let inCode = false;
      let codeBlock = null;
      let list = null;

      const flushList = () => {
        if (list) {
          fragment.appendChild(list);
          list = null;
        }
      };

      const appendInline = (parent, content) => {
        const nodes = renderInlineMarkdownLinks(content, references);
        nodes.forEach((node) => parent.appendChild(node));
      };

      for (const rawLine of contentLines) {
        const line = rawLine.replace(/\s+$/g, "");

        if (line.startsWith("```")) {
          if (!inCode) {
            flushList();
            inCode = true;
            codeBlock = document.createElement("pre");
          } else {
            fragment.appendChild(codeBlock || document.createElement("pre"));
            inCode = false;
            codeBlock = null;
          }
          continue;
        }

        if (inCode) {
          codeBlock.textContent += `${line}\n`;
          continue;
        }

        const headingMatch = line.match(/^(#{1,4})\s+(.*)$/);
        if (headingMatch) {
          flushList();
          const level = Math.min(4, headingMatch[1].length);
          const tag = level === 1 ? "h2" : level === 2 ? "h3" : "h4";
          const heading = document.createElement(tag);
          appendInline(heading, headingMatch[2]);
          fragment.appendChild(heading);
          continue;
        }

        if (/^\s*(-|\*|\d+\.)\s+/.test(line)) {
          if (!list) {
            list = document.createElement("ul");
          }
          const item = document.createElement("li");
          appendInline(item, line.replace(/^\s*(-|\*|\d+\.)\s+/, ""));
          list.appendChild(item);
          continue;
        }

        if (/^\s*>\s+/.test(line)) {
          flushList();
          const quote = document.createElement("blockquote");
          appendInline(quote, line.replace(/^\s*>\s+/, ""));
          fragment.appendChild(quote);
          continue;
        }

        if (/^\s*---+\s*$/.test(line)) {
          flushList();
          const rule = document.createElement("div");
          rule.style.borderTop = `1px solid ${getComputedStyle(document.documentElement).getPropertyValue("--line")}`;
          rule.style.margin = "8px 0";
          fragment.appendChild(rule);
          continue;
        }

        if (!line.trim()) {
          flushList();
          continue;
        }

        flushList();
        const para = document.createElement("p");
        appendInline(para, line);
        fragment.appendChild(para);
      }

      flushList();
      return fragment;
    }

    function renderInlineMarkdownLinks(text, references) {
      const nodes = [];
      const pattern = /!\[([^\]]*)\]\(([^)]+)\)|!\[([^\]]*)\]\[([^\]]+)\]|\[([^\]]+)\]\(([^)]+)\)|\[([^\]]+)\]\[([^\]]+)\]|(https?:\/\/[^\s<]+|www\.[^\s<]+)/g;
      let lastIndex = 0;
      let match = pattern.exec(text);

      while (match) {
        if (match.index > lastIndex) {
          nodes.push(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        if (match[1] !== undefined) {
          const alt = match[1];
          const src = match[2].trim();
          const img = document.createElement("img");
          img.src = src;
          img.alt = alt;
          nodes.push(img);
        } else if (match[3] !== undefined) {
          const alt = match[3];
          const refKey = match[4].trim().toLowerCase();
          const ref = references[refKey];
          if (ref && !/^javascript:/i.test(ref.href)) {
            const img = document.createElement("img");
            img.src = ref.href;
            img.alt = alt;
            if (ref.title) img.title = ref.title;
            nodes.push(img);
          } else {
            nodes.push(document.createTextNode(match[0]));
          }
        } else if (match[5] !== undefined) {
          const label = match[5];
          const href = match[6].trim();
          if (href.startsWith("@")) {
            const recordId = href;
            if (state.records[recordId]) {
              const link = document.createElement("a");
              link.href = "#";
              link.textContent = label;
              link.addEventListener("click", (event) => {
                event.preventDefault();
                selectRecord(recordId);
              });
              nodes.push(link);
            } else {
              const missing = document.createElement("span");
              missing.className = "muted";
              missing.textContent = label;
              nodes.push(missing);
            }
          } else if (/^javascript:/i.test(href)) {
            nodes.push(document.createTextNode(match[0]));
          } else {
            const link = document.createElement("a");
            link.href = href;
            link.textContent = label;
            nodes.push(link);
          }
        } else if (match[7] !== undefined) {
          const label = match[7];
          const refKey = match[8].trim().toLowerCase();
          const ref = references[refKey];
          if (ref && ref.href && ref.href.trim().startsWith("@")) {
            const recordId = ref.href.trim();
            if (state.records[recordId]) {
              const link = document.createElement("a");
              link.href = "#";
              link.textContent = label;
              link.addEventListener("click", (event) => {
                event.preventDefault();
                selectRecord(recordId);
              });
              nodes.push(link);
            } else {
              const missing = document.createElement("span");
              missing.className = "muted";
              missing.textContent = label;
              nodes.push(missing);
            }
          } else if (ref && !/^javascript:/i.test(ref.href)) {
            const link = document.createElement("a");
            link.href = ref.href;
            link.textContent = label;
            if (ref.title) link.title = ref.title;
            nodes.push(link);
          } else {
            nodes.push(document.createTextNode(match[0]));
          }
        } else if (match[9] !== undefined) {
          const raw = match[9];
          const href = raw.startsWith("www.") ? `https://${raw}` : raw;
          const link = document.createElement("a");
          link.href = href;
          link.textContent = raw;
          nodes.push(link);
        }

        lastIndex = match.index + match[0].length;
        match = pattern.exec(text);
      }

      if (lastIndex < text.length) {
        nodes.push(document.createTextNode(text.slice(lastIndex)));
      }

      if (!nodes.length) {
        nodes.push(document.createTextNode(text));
      }

      return nodes;
    }

    function renderGraph() {
      const parent = graphCanvas.parentElement;
      const width = parent.clientWidth;
      const height = parent.clientHeight;
      graphCanvas.width = Math.max(1, Math.floor(width * devicePixelRatio));
      graphCanvas.height = Math.max(1, Math.floor(height * devicePixelRatio));
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

      ctx.clearRect(0, 0, width, height);
      if (!state.order.length) return;

      const nodes = [...state.order];
      const edges = [];
      nodes.forEach((source) => {
        (state.records[source]?.edges || []).forEach((edge) => {
          if (state.records[edge.target]) {
            edges.push([source, edge.target]);
          }
        });
      });

      const positions = computeForceLayout(nodes, edges, width, height, 20);
      state.positions = positions;

      const selected = state.selectedId;
      const neighbors = new Set();
      if (selected && state.records[selected]) {
        state.records[selected].edges.forEach((edge) => neighbors.add(edge.target));
      }

      edges.forEach(([source, target]) => {
        const start = positions[source];
        const end = positions[target];
        ctx.beginPath();
        ctx.moveTo(start[0], start[1]);
        ctx.lineTo(end[0], end[1]);
        ctx.strokeStyle = source === selected || target === selected ? palette.accent : palette.line;
        ctx.lineWidth = source === selected || target === selected ? 2 : 1;
        ctx.stroke();
      });

      nodes.forEach((node) => {
        const [x, y] = positions[node];
        const isSelected = node === selected;
        const isNeighbor = neighbors.has(node);
        const radius = isSelected ? 8 : 6;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = isSelected ? palette.accentAlt : palette.muted;
        ctx.fill();
        ctx.lineWidth = isNeighbor ? 2 : 1;
        ctx.strokeStyle = isNeighbor ? palette.accent : palette.ink;
        ctx.stroke();

        if (isSelected || isNeighbor) {
          ctx.fillStyle = palette.ink;
          ctx.font = "bold 11px Space Grotesk";
          ctx.fillText(node, x + 8, y - 8);
        }
      });
    }

    function computeForceLayout(nodes, edges, width, height, padding) {
      const positions = {};
      const rng = mulberry32(42);
      nodes.forEach((node) => {
        if (state.positions[node]) {
          positions[node] = [...state.positions[node]];
        } else {
          positions[node] = [
            padding + rng() * (width - 2 * padding),
            padding + rng() * (height - 2 * padding),
          ];
        }
      });

      const area = Math.max((width - 2 * padding) * (height - 2 * padding), 1);
      const k = Math.sqrt(area / Math.max(nodes.length, 1));
      let temperature = Math.min(width, height) / 4;

      for (let iter = 0; iter < 60; iter += 1) {
        const disp = {};
        nodes.forEach((node) => {
          disp[node] = [0, 0];
        });

        for (let i = 0; i < nodes.length; i += 1) {
          for (let j = i + 1; j < nodes.length; j += 1) {
            const v = nodes[i];
            const u = nodes[j];
            const dx = positions[v][0] - positions[u][0];
            const dy = positions[v][1] - positions[u][1];
            const dist = Math.hypot(dx, dy) || 0.001;
            const force = (k * k) / dist;
            const rx = (dx / dist) * force;
            const ry = (dy / dist) * force;
            disp[v][0] += rx;
            disp[v][1] += ry;
            disp[u][0] -= rx;
            disp[u][1] -= ry;
          }
        }

        edges.forEach(([v, u]) => {
          const dx = positions[v][0] - positions[u][0];
          const dy = positions[v][1] - positions[u][1];
          const dist = Math.hypot(dx, dy) || 0.001;
          const force = (dist * dist) / k;
          const ax = (dx / dist) * force;
          const ay = (dy / dist) * force;
          disp[v][0] -= ax;
          disp[v][1] -= ay;
          disp[u][0] += ax;
          disp[u][1] += ay;
        });

        nodes.forEach((node) => {
          const dx = disp[node][0];
          const dy = disp[node][1];
          const dist = Math.hypot(dx, dy) || 0.001;
          const limited = Math.min(dist, temperature);
          positions[node][0] += (dx / dist) * limited;
          positions[node][1] += (dy / dist) * limited;
          positions[node][0] = Math.min(width - padding, Math.max(padding, positions[node][0]));
          positions[node][1] = Math.min(height - padding, Math.max(padding, positions[node][1]));
        });

        temperature *= 0.92;
      }

      return positions;
    }

    function mulberry32(seed) {
      return function () {
        let t = seed += 0x6d2b79f5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    graphCanvas.addEventListener("click", (event) => {
      const rect = graphCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      let closest = null;
      let closestDist = Infinity;
      Object.entries(state.positions).forEach(([id, pos]) => {
        const dx = pos[0] - x;
        const dy = pos[1] - y;
        const dist = Math.hypot(dx, dy);
        if (dist < closestDist) {
          closestDist = dist;
          closest = id;
        }
      });
      if (closest && closestDist < 16) {
        selectRecord(closest);
      }
    });

    function startAutoRefresh() {
      setInterval(() => {
        if (autoRefresh.checked) {
          loadDb();
        }
      }, REFRESH_MS);
    }

    loadDb(true);
    startAutoRefresh();
  </script>
</body>
</html>
