<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Toot Toot Terminology</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Unbounded:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="css/eyeball.css" />
  <link rel="stylesheet" href="css/tte-common.css" />
  <link rel="stylesheet" href="css/tte-core.css" />
  <style>
    .page {
      max-width: 100%;
      margin: 0 auto;
      padding: 32px clamp(18px, 4vw, 48px) 48px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      position: relative;
      z-index: 1;
    }

    .home-link {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 10;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(192, 232, 207, 0.92);
      color: var(--ink);
      font-size: 14px;
      text-decoration: none;
      box-shadow: 0 10px 24px rgba(11, 17, 18, 0.18);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }

    .home-link:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0 14px var(--glow);
    }

    header {
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
      padding: 18px 22px;
      width: 100%;
      border-radius: 20px;
      background: rgba(192, 232, 207, 0.88);
      border: 1px solid rgba(11, 17, 18, 0.12);
      box-shadow: 0 18px 36px rgba(11, 17, 18, 0.18);
    }

    .header-left {
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .hero-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .title-block h1 {
      margin: 0;
      font-family: "Unbounded", "Space Grotesk", sans-serif;
      font-size: clamp(26px, 4vw, 38px);
    }

    .title-block p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 14px;
    }

    .eyeball-slot {
      display: grid;
      place-items: center;
      width: 88px;
      height: 88px;
      border-radius: 20px;
      background: rgba(11, 17, 18, 0.1);
      border: 1px solid rgba(11, 17, 18, 0.12);
    }

    .graph-wrap {
      width: 100%;
      height: 260px;
      border-radius: 18px;
      background: rgba(11, 17, 18, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(220px, 0.75fr) minmax(300px, 2fr);
      gap: 20px;
      min-height: 70vh;
      align-items: start;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 16px 36px rgba(11, 17, 18, 0.14);
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-content: start;
      height: 100%;
    }

    .panel.record-panel {
      height: auto;
    }

    .info-panel {
      max-width: 900px;
      margin: 0 auto;
    }

    .info-panel summary {
      cursor: pointer;
      font-family: "Unbounded", "Space Grotesk", sans-serif;
      font-size: 18px;
      color: var(--title);
      list-style: none;
    }

    .info-panel summary::-webkit-details-marker {
      display: none;
    }

    .info-panel summary::after {
      content: "▾";
      margin-left: 8px;
      font-size: 16px;
      color: var(--accent);
    }

    .info-panel[open] summary::after {
      content: "▴";
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }

    .pill {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-2);
      color: var(--ink);
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .pill:hover {
      transform: translateY(-1px);
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--glow);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel-2);
      font-size: 14px;
      color: var(--ink);
    }

    .toggle input {
      accent-color: var(--accent);
    }

    .search {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(11, 17, 18, 0.2);
      background: rgba(255, 255, 255, 0.85);
      font-family: inherit;
      font-size: 14px;
    }

    .search-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
      overflow: auto;
      align-content: start;
      flex: 1;
      min-height: 0;
      max-height: 420px;
    }

    .list button {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: var(--panel-2);
      color: var(--ink);
      font-family: inherit;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .list button:hover {
      border-color: rgba(124, 199, 255, 0.4);
    }

    .list button.active {
      border-color: var(--accent);
      background: rgba(15, 139, 141, 0.12);
      box-shadow: inset 0 0 0 1px rgba(15, 139, 141, 0.2);
    }

    .record {
      display: grid;
      gap: 14px;
      min-height: 240px;
      overflow: auto;
      padding-right: 6px;
    }

    .record h2,
    .record h3,
    .record h4 {
      margin: 0;
      font-family: "Unbounded", "Space Grotesk", sans-serif;
    }

    .record h2 {
      color: var(--title);
      font-size: 22px;
    }

    .record h3 {
      color: var(--accent);
      font-size: 16px;
    }

    .record h4 {
      font-size: 14px;
    }

    .record p,
    .record li,
    .record blockquote {
      margin: 0;
      font-size: 15px;
      line-height: 1.6;
      color: var(--ink);
    }

    .record ul {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
    }

    .record blockquote {
      border-left: 3px solid var(--accent);
      padding-left: 12px;
      color: var(--muted);
    }

    .record img,
    .record object {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(11, 17, 18, 0.12);
      background: rgba(255, 255, 255, 0.9);
    }

    .record object {
      width: 100%;
      min-height: 180px;
    }

    .related {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
    }

    .related li {
      display: flex;
      gap: 8px;
      align-items: baseline;
      font-size: 14px;
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .tour-note {
      font-size: 13px;
      color: var(--muted);
    }

    footer {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: center;
      color: rgba(230, 255, 240, 0.7);
      padding: 24px 0 8px;
    }

    @media (max-width: 900px) {
      header {
        grid-template-columns: 1fr;
      }

      .layout {
        grid-template-columns: 1fr;
      }

      .graph-wrap {
        height: 220px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <a class="home-link" href="index.html">TTE Home</a>
    <header>
      <div class="header-left">
        <div class="graph-wrap">
          <canvas id="graph"></canvas>
        </div>
      </div>
      <div class="header-right">
        <div class="record" id="recordView"></div>
      </div>
    </header>

    <section class="panel">
      <strong>Records</strong>
      <input class="search" id="searchInput" type="search" placeholder="Search terms, examples, or links" />
      <div class="search-meta" id="searchMeta">Loading...</div>
      <ul class="list" id="recordList"></ul>
    </section>

    <details class="panel record-panel info-panel">
      <summary>TTDB: Terminology</summary>
      <div class="title">
        <p>Single-file glossary DB. Guided tour starts at Umwelt and steps through each term.</p>
        <span id="status">Loading TootTootTerminologyDB.md...</span>
      </div>
      <div class="controls">
        <button class="pill" id="refresh">Refresh</button>
        <label class="toggle">
          <input type="checkbox" id="autoRefresh" checked />
          Auto refresh
        </label>
        <label class="toggle">
          <input type="checkbox" id="tourToggle" checked />
          Guided tour
        </label>
      </div>
      <div class="tour-note" id="tourNote">Default network tour will advance after a short pause.</div>
    </details>

    <footer>
      <span id="eyeball-foot"></span>
      &copy; 2026 Toot Toot Engineering. All signals cleared.
    </footer>
  </div>

  <script src="js/eyeball.js"></script>
  <script>
    const DB_PATH = "TootTootTerminologyDB.md";
    const REFRESH_MS = 8000;
    const TOUR_DELAY_MS = 12000;

    const state = {
      records: {},
      order: [],
      filteredOrder: [],
      selectedId: null,
      lastText: "",
      coords: {},
      screenPoints: {},
      globeRotLat: 0,
      globeRotLon: 0,
      globeTargetLat: 0,
      globeTargetLon: 0,
      globeAnimating: false,
      searchIndex: {},
      searchTerm: "",
      tourEnabled: true,
      tourTimer: null,
    };

    const palette = (() => {
      const styles = getComputedStyle(document.documentElement);
      const read = (name, fallback) => styles.getPropertyValue(name).trim() || fallback;
      return {
        accent: read("--accent", "#0f8b8d"),
        accentAlt: read("--accent-2", "#e76f51"),
        ink: read("--ink", "#0b1112"),
        muted: read("--muted", "rgba(11, 17, 18, 0.6)"),
        line: read("--line", "rgba(11, 17, 18, 0.2)"),
      };
    })();

    const statusEl = document.getElementById("status");
    const listEl = document.getElementById("recordList");
    const viewEl = document.getElementById("recordView");
    const graphCanvas = document.getElementById("graph");
    const refreshBtn = document.getElementById("refresh");
    const autoRefresh = document.getElementById("autoRefresh");
    const searchInput = document.getElementById("searchInput");
    const searchMeta = document.getElementById("searchMeta");
    const tourToggle = document.getElementById("tourToggle");
    const tourNote = document.getElementById("tourNote");

    const ctx = graphCanvas.getContext("2d");
    const resizeObserver = new ResizeObserver(() => renderGraph());
    resizeObserver.observe(graphCanvas.parentElement);

    refreshBtn.addEventListener("click", () => loadDb(true));
    searchInput.addEventListener("input", () => {
      state.searchTerm = searchInput.value.trim().toLowerCase();
      applySearch();
      noteInteraction();
    });
    tourToggle.addEventListener("change", () => {
      state.tourEnabled = tourToggle.checked;
      if (state.tourEnabled) {
        scheduleTour();
      } else {
        clearTour();
      }
    });

    function setStatusMessage(message) {
      statusEl.textContent = message;
    }

    function setStatusLink(recordCount) {
      statusEl.innerHTML = `DB: <a href="${DB_PATH}">${DB_PATH}</a> · ${recordCount} records`;
    }

    function sanitize(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    function buildSearchIndex() {
      state.searchIndex = {};
      state.order.forEach((recordId) => {
        const record = state.records[recordId];
        if (!record) return;
        const text = [record.title, record.header, record.body].filter(Boolean).join("\n");
        state.searchIndex[recordId] = text.toLowerCase();
      });
    }

    function applySearch() {
      const term = state.searchTerm;
      if (!term) {
        state.filteredOrder = [...state.order];
      } else {
        state.filteredOrder = state.order.filter((recordId) => {
          const blob = state.searchIndex[recordId] || "";
          return blob.includes(term);
        });
      }

      if (state.filteredOrder.length && !state.filteredOrder.includes(state.selectedId)) {
        state.selectedId = state.filteredOrder[0];
      }

      renderList();
      renderRecord();
      centerOnSelected();
      renderGraph();
      updateSearchMeta();
    }

    function updateSearchMeta() {
      if (!state.order.length) {
        searchMeta.textContent = "No records.";
        return;
      }
      if (!state.searchTerm) {
        searchMeta.textContent = `${state.order.length} terms loaded.`;
        return;
      }
      searchMeta.textContent = `${state.filteredOrder.length} matches for "${sanitize(state.searchTerm)}".`;
    }

    function loadDb(force = false) {
      fetch(DB_PATH, { cache: "no-store" })
        .then((res) => {
          if (!res.ok) throw new Error(`Failed to load ${DB_PATH}`);
          return res.text();
        })
        .then((text) => {
          if (!force && text === state.lastText) return;
          state.lastText = text;
          const { records, order, selected, coords } = parseRecords(text);
          state.records = records;
          state.order = order;
          state.coords = coords;
          buildSearchIndex();
          if (!state.selectedId || !records[state.selectedId]) {
            state.selectedId = selected || order[0] || null;
          }
          applySearch();
          renderRecord();
          centerOnSelected();
          renderGraph();
          setStatusLink(order.length);
          scheduleTour();
        })
        .catch((err) => {
          setStatusMessage(err.message);
          state.records = {};
          state.order = [];
          state.filteredOrder = [];
          state.selectedId = null;
          state.coords = {};
          renderList();
          renderRecord();
          renderGraph();
          updateSearchMeta();
        });
    }

    function parseRecords(content) {
      let selected = null;
      const cursorMatch = content.match(/```cursor([\s\S]*?)```/);
      if (cursorMatch) {
        const lines = cursorMatch[1].split(/\r?\n/);
        let inSelected = false;
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith("selected:")) {
            inSelected = true;
            continue;
          }
          if (inSelected) {
            const itemMatch = trimmed.match(/^-\s*(\S+)/);
            if (itemMatch) {
              selected = itemMatch[1];
              break;
            }
            if (trimmed && !trimmed.startsWith("-")) {
              break;
            }
          }
        }
      }

      const records = {};
      const order = [];
      const coords = {};
      const blocks = content.split(/^\s*---+\s*$/m);
      for (const block of blocks) {
        const lines = block.split(/\r?\n/);
        let headerIndex = -1;
        for (let i = 0; i < lines.length; i += 1) {
          if (lines[i].startsWith("@")) {
            headerIndex = i;
            break;
          }
        }
        if (headerIndex < 0) continue;
        const headerLine = lines[headerIndex].trim();
        const recordId = headerLine.split(/\s+/)[0];
        const bodyLines = lines.slice(headerIndex + 1);
        let title = null;
        let titleRemoved = false;
        const filteredBodyLines = [];
        for (const line of bodyLines) {
          const match = line.match(/^##\s+(.*)$/);
          if (match && !titleRemoved) {
            title = match[1].trim();
            titleRemoved = true;
            continue;
          }
          filteredBodyLines.push(line);
        }
        const body = filteredBodyLines.join("\n").trim();

        const edges = [];
        const relatesMatch = headerLine.match(/relates:([^|]+)/);
        if (relatesMatch) {
          const tokens = relatesMatch[1].split(",");
          for (const tokenRaw of tokens) {
            const token = tokenRaw.trim();
            if (!token) continue;
            let edgeType = "relates";
            let target = token;
            if (token.includes(">")) {
              const [left, right] = token.split(">", 2);
              edgeType = left.trim();
              target = right.trim();
            }
            edges.push({ type: edgeType, target });
          }
        }

        const recordCoords = parseCoords(recordId);
        if (recordCoords) {
          coords[recordId] = recordCoords;
        }

        records[recordId] = { header: headerLine, body, title, edges };
        order.push(recordId);
      }

      return { records, order, selected, coords };
    }

    function parseCoords(recordId) {
      const match = recordId.match(/^@LAT(-?\d+(?:\.\d+)?)LON(-?\d+(?:\.\d+)?)$/);
      if (!match) return null;
      return [Number(match[1]), Number(match[2])];
    }

    function renderList() {
      listEl.innerHTML = "";
      const source = state.searchTerm ? state.filteredOrder : state.order;
      if (!source.length) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "No records available.";
        listEl.appendChild(empty);
        return;
      }

      source.forEach((recordId) => {
        const title = state.records[recordId]?.title;
        const label = title ? `${recordId} - ${title}` : recordId;
        const li = document.createElement("li");
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = label;
        if (recordId === state.selectedId) {
          button.classList.add("active");
        }
        button.addEventListener("click", () => {
          selectRecord(recordId);
          noteInteraction();
        });
        li.appendChild(button);
        listEl.appendChild(li);
      });
    }

    function selectRecord(recordId, opts = {}) {
      if (!state.records[recordId]) return;
      state.selectedId = recordId;
      renderList();
      renderRecord();
      centerOnSelected();
      renderGraph();
      if (!opts.fromTour) {
        scheduleTour();
      }
    }

    function renderRecord() {
      viewEl.innerHTML = "";
      if (!state.selectedId || !state.records[state.selectedId]) {
        viewEl.textContent = "No record selected.";
        return;
      }

      const record = state.records[state.selectedId];
      const leadMediaInfo = extractLeadMedia(record.body || "");
      if (record.title) {
        const title = document.createElement("h2");
        title.className = "record-title";
        title.textContent = record.title;
        viewEl.appendChild(title);
      }

      if (leadMediaInfo.leadMedia) {
        viewEl.appendChild(leadMediaInfo.leadMedia);
      }

      if (leadMediaInfo.body) {
        viewEl.appendChild(renderMarkdown(leadMediaInfo.body));
      }

      if (record.edges.length) {
        const relatedTitle = document.createElement("h3");
        relatedTitle.textContent = "Related records";
        viewEl.appendChild(relatedTitle);

        const list = document.createElement("ul");
        list.className = "related";
        record.edges.forEach((edge) => {
          const item = document.createElement("li");
          const label = document.createElement("span");
          label.textContent = `${edge.type} -> `;
          item.appendChild(label);
          if (state.records[edge.target]) {
            const link = document.createElement("a");
            link.href = "#";
            link.textContent = state.records[edge.target]?.title || edge.target;
            link.addEventListener("click", (event) => {
              event.preventDefault();
              selectRecord(edge.target);
              noteInteraction();
            });
            item.appendChild(link);
          } else {
            const missing = document.createElement("span");
            missing.className = "muted";
            missing.textContent = edge.target;
            item.appendChild(missing);
          }
          list.appendChild(item);
        });
        viewEl.appendChild(list);
      }
    }

    function createMediaNode(src, alt, title) {
      const cleaned = src.split("?")[0].split("#")[0].toLowerCase();
      const isSvg = cleaned.endsWith(".svg");
      if (isSvg) {
        const obj = document.createElement("object");
        obj.data = src;
        obj.type = "image/svg+xml";
        obj.setAttribute("role", "img");
        obj.setAttribute("aria-label", alt || "svg image");
        if (title) obj.setAttribute("title", title);
        return obj;
      }
      const img = document.createElement("img");
      img.src = src;
      img.alt = alt;
      if (title) img.title = title;
      img.loading = "lazy";
      return img;
    }

    function extractLeadMedia(text) {
      if (!text) return { body: text, leadMedia: null };
      const lines = text.split(/\r?\n/);
      const references = {};
      const refPattern = /^\s*\[([^\]]+)\]:\s*(\S+)(?:\s+"([^"]+)")?\s*$/;
      let inRefCode = false;
      lines.forEach((rawLine) => {
        const trimmed = rawLine.trim();
        if (trimmed.startsWith("```")) {
          inRefCode = !inRefCode;
          return;
        }
        if (inRefCode) return;
        const match = rawLine.match(refPattern);
        if (match) {
          references[match[1].trim().toLowerCase()] = {
            href: match[2],
            title: match[3] || "",
          };
        }
      });

      const imagePattern = /!\[([^\]]*)\]\(([^)]+)\)|!\[([^\]]*)\]\[([^\]]+)\]/;
      const output = [];
      let leadMedia = null;
      let inCode = false;

      for (const rawLine of lines) {
        const trimmed = rawLine.trim();
        if (trimmed.startsWith("```")) {
          inCode = !inCode;
          output.push(rawLine);
          continue;
        }
        if (inCode || leadMedia) {
          output.push(rawLine);
          continue;
        }

        const match = rawLine.match(imagePattern);
        if (!match) {
          output.push(rawLine);
          continue;
        }

        if (match[1] !== undefined) {
          const alt = match[1];
          const src = match[2].trim();
          if (!/^javascript:/i.test(src)) {
            leadMedia = createMediaNode(src, alt);
          }
        } else if (match[3] !== undefined) {
          const alt = match[3];
          const refKey = match[4].trim().toLowerCase();
          const ref = references[refKey];
          if (ref && !/^javascript:/i.test(ref.href)) {
            leadMedia = createMediaNode(ref.href, alt, ref.title);
          }
        }

        const before = rawLine.slice(0, match.index);
        const after = rawLine.slice(match.index + match[0].length);
        const rebuilt = `${before}${after}`;
        output.push(rebuilt);
      }

      return { body: output.join("\n"), leadMedia };
    }

    function renderMarkdown(text) {
      const fragment = document.createDocumentFragment();
      const lines = text.split(/\r?\n/);
      const references = {};
      const contentLines = [];
      const refPattern = /^\s*\[([^\]]+)\]:\s*(\S+)(?:\s+"([^"]+)")?\s*$/;
      let inRefCode = false;
      lines.forEach((rawLine) => {
        const trimmed = rawLine.trim();
        if (trimmed.startsWith("```")) {
          inRefCode = !inRefCode;
          contentLines.push(rawLine);
          return;
        }
        if (inRefCode) {
          contentLines.push(rawLine);
          return;
        }
        const match = rawLine.match(refPattern);
        if (match) {
          references[match[1].trim().toLowerCase()] = {
            href: match[2],
            title: match[3] || "",
          };
          return;
        }
        contentLines.push(rawLine);
      });
      let inCode = false;
      let codeBlock = null;
      let list = null;

      const flushList = () => {
        if (list) {
          fragment.appendChild(list);
          list = null;
        }
      };

      const appendInline = (parent, content) => {
        const nodes = renderInlineMarkdownLinks(content, references);
        nodes.forEach((node) => parent.appendChild(node));
      };

      for (const rawLine of contentLines) {
        const line = rawLine.replace(/\s+$/g, "");

        if (line.startsWith("```")) {
          if (!inCode) {
            flushList();
            inCode = true;
            codeBlock = document.createElement("pre");
          } else {
            fragment.appendChild(codeBlock || document.createElement("pre"));
            inCode = false;
            codeBlock = null;
          }
          continue;
        }

        if (inCode) {
          codeBlock.textContent += `${line}\n`;
          continue;
        }

        const headingMatch = line.match(/^(#{1,4})\s+(.*)$/);
        if (headingMatch) {
          flushList();
          const level = Math.min(4, headingMatch[1].length);
          const tag = level === 1 ? "h2" : level === 2 ? "h3" : "h4";
          const heading = document.createElement(tag);
          appendInline(heading, headingMatch[2]);
          fragment.appendChild(heading);
          continue;
        }

        if (/^\s*(-|\*|\d+\.)\s+/.test(line)) {
          if (!list) {
            list = document.createElement("ul");
          }
          const item = document.createElement("li");
          appendInline(item, line.replace(/^\s*(-|\*|\d+\.)\s+/, ""));
          list.appendChild(item);
          continue;
        }

        if (/^\s*>\s+/.test(line)) {
          flushList();
          const quote = document.createElement("blockquote");
          appendInline(quote, line.replace(/^\s*>\s+/, ""));
          fragment.appendChild(quote);
          continue;
        }

        if (/^\s*---+\s*$/.test(line)) {
          flushList();
          const rule = document.createElement("div");
          rule.style.borderTop = `1px solid ${getComputedStyle(document.documentElement).getPropertyValue("--line")}`;
          rule.style.margin = "8px 0";
          fragment.appendChild(rule);
          continue;
        }

        if (!line.trim()) {
          flushList();
          continue;
        }

        flushList();
        const para = document.createElement("p");
        appendInline(para, line);
        fragment.appendChild(para);
      }

      flushList();
      return fragment;
    }

    function renderInlineMarkdownLinks(text, references) {
      const nodes = [];
      const pattern = /!\[([^\]]*)\]\(([^)]+)\)|!\[([^\]]*)\]\[([^\]]+)\]|\[([^\]]+)\]\(([^)]+)\)|\[([^\]]+)\]\[([^\]]+)\]|(https?:\/\/[^\s<]+|www\.[^\s<]+)/g;
      let lastIndex = 0;
      let match = pattern.exec(text);

      while (match) {
        if (match.index > lastIndex) {
          nodes.push(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        if (match[1] !== undefined) {
          const alt = match[1];
          const src = match[2].trim();
          nodes.push(createMediaNode(src, alt));
        } else if (match[3] !== undefined) {
          const alt = match[3];
          const refKey = match[4].trim().toLowerCase();
          const ref = references[refKey];
          if (ref && !/^javascript:/i.test(ref.href)) {
            nodes.push(createMediaNode(ref.href, alt, ref.title));
          } else {
            nodes.push(document.createTextNode(match[0]));
          }
        } else if (match[5] !== undefined) {
          const label = match[5];
          const href = match[6].trim();
          if (href.startsWith("@")) {
            const recordId = href;
            if (state.records[recordId]) {
              const link = document.createElement("a");
              link.href = "#";
              link.textContent = label;
              link.addEventListener("click", (event) => {
                event.preventDefault();
                selectRecord(recordId);
                noteInteraction();
              });
              nodes.push(link);
            } else {
              const missing = document.createElement("span");
              missing.className = "muted";
              missing.textContent = label;
              nodes.push(missing);
            }
          } else if (/^javascript:/i.test(href)) {
            nodes.push(document.createTextNode(match[0]));
          } else {
            const link = document.createElement("a");
            link.href = href;
            link.textContent = label;
            nodes.push(link);
          }
        } else if (match[7] !== undefined) {
          const label = match[7];
          const refKey = match[8].trim().toLowerCase();
          const ref = references[refKey];
          if (ref && ref.href && ref.href.trim().startsWith("@")) {
            const recordId = ref.href.trim();
            if (state.records[recordId]) {
              const link = document.createElement("a");
              link.href = "#";
              link.textContent = label;
              link.addEventListener("click", (event) => {
                event.preventDefault();
                selectRecord(recordId);
                noteInteraction();
              });
              nodes.push(link);
            } else {
              const missing = document.createElement("span");
              missing.className = "muted";
              missing.textContent = label;
              nodes.push(missing);
            }
          } else if (ref && !/^javascript:/i.test(ref.href)) {
            const link = document.createElement("a");
            link.href = ref.href;
            link.textContent = label;
            if (ref.title) link.title = ref.title;
            nodes.push(link);
          } else {
            nodes.push(document.createTextNode(match[0]));
          }
        } else if (match[9] !== undefined) {
          const raw = match[9];
          const href = raw.startsWith("www.") ? `https://${raw}` : raw;
          const link = document.createElement("a");
          link.href = href;
          link.textContent = raw;
          nodes.push(link);
        }

        lastIndex = match.index + match[0].length;
        match = pattern.exec(text);
      }

      if (lastIndex < text.length) {
        nodes.push(document.createTextNode(text.slice(lastIndex)));
      }

      if (!nodes.length) {
        nodes.push(document.createTextNode(text));
      }

      return nodes;
    }

    function renderGraph() {
      const parent = graphCanvas.parentElement;
      const width = parent.clientWidth;
      const height = parent.clientHeight;
      graphCanvas.width = Math.max(1, Math.floor(width * devicePixelRatio));
      graphCanvas.height = Math.max(1, Math.floor(height * devicePixelRatio));
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

      ctx.clearRect(0, 0, width, height);

      const padding = 6;
      const radius = Math.min(width, height) / 2 - padding;
      if (radius <= 10) return;

      const cx = width / 2;
      const cy = height / 2;

      ctx.fillStyle = "#0e1117";
      ctx.strokeStyle = "#2a2f3a";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = "#141824";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.92, 0, Math.PI * 2);
      ctx.stroke();

      drawGraticule(cx, cy, radius);

      const coordsEntries = Object.entries(state.coords);
      if (!coordsEntries.length) return;

      const selected = state.selectedId;
      const nodesFront = [];
      const nodesBack = [];
      const projections = {};
      let selectedPoint = null;
      coordsEntries.forEach(([recordId, [lat, lon]]) => {
        const [x, y, z] = projectPoint(lat, lon);
        projections[recordId] = [x, y, z];
        if (recordId === selected) {
          selectedPoint = [recordId, x, y, z];
        } else if (z > 0) {
          nodesFront.push([recordId, x, y, z]);
        } else {
          nodesBack.push([recordId, x, y, z]);
        }
      });

      ctx.fillStyle = "#2b303b";
      nodesBack.forEach(([, x, y]) => {
        const px = cx + x * radius;
        const py = cy - y * radius;
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      Object.entries(state.records).forEach(([sourceId, record]) => {
        const edges = record.edges || [];
        if (!edges.length) return;
        const sourceProj = projections[sourceId];
        if (!sourceProj) return;
        const [sx, sy, sz] = sourceProj;
        if (sz <= 0) return;
        const sxp = cx + sx * radius;
        const syp = cy - sy * radius;
        edges.forEach((edge) => {
          const targetId = edge.target;
          if (!targetId) return;
          const targetProj = projections[targetId];
          if (!targetProj) return;
          const [tx, ty, tz] = targetProj;
          if (tz <= 0) return;
          const txp = cx + tx * radius;
          const typ = cy - ty * radius;
          const isSelectedEdge = sourceId === selected || targetId === selected;
          ctx.strokeStyle = isSelectedEdge ? "#7cc7ff" : "#2a3a4d";
          ctx.lineWidth = isSelectedEdge ? 2 : 1;
          ctx.beginPath();
          ctx.moveTo(sxp, syp);
          ctx.lineTo(txp, typ);
          ctx.stroke();
        });
      });

      state.screenPoints = {};
      nodesFront.forEach(([recordId, x, y]) => {
        const px = cx + x * radius;
        const py = cy - y * radius;
        ctx.fillStyle = "#7cc7ff";
        ctx.strokeStyle = "#0b0b10";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        state.screenPoints[recordId] = [px, py];
      });

      if (selectedPoint) {
        const [recordId, x, y] = selectedPoint;
        const px = cx + x * radius;
        const py = cy - y * radius;
        ctx.fillStyle = "#ffd166";
        ctx.strokeStyle = "#f4a261";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        state.screenPoints[recordId] = [px, py];

        ctx.fillStyle = "#e9e9f0";
        ctx.font = "bold 11px Space Grotesk";
        ctx.fillText(recordId, px + 8, py - 8);
      }
    }

    function centerOnSelected() {
      const recordId = state.selectedId;
      if (!recordId) return;
      const coords = state.coords[recordId];
      if (!coords) return;
      const [lat, lon] = coords;
      const latR = (lat * Math.PI) / 180;
      const lonR = (lon * Math.PI) / 180;
      const x = Math.cos(latR) * Math.sin(lonR);
      const y = Math.sin(latR);
      const z = Math.cos(latR) * Math.cos(lonR);
      const rotLon = -Math.atan2(x, z);
      const z1 = Math.hypot(x, z);
      const rotLat = Math.atan2(y, z1);
      state.globeTargetLat = rotLat;
      state.globeTargetLon = rotLon;
      if (!state.globeAnimating) {
        state.globeAnimating = true;
        requestAnimationFrame(animateGlobe);
      }
    }

    function animateGlobe() {
      if (!state.globeAnimating) return;
      const deltaLat = angleDelta(state.globeTargetLat, state.globeRotLat);
      const deltaLon = angleDelta(state.globeTargetLon, state.globeRotLon);

      if (Math.abs(deltaLat) < 0.002 && Math.abs(deltaLon) < 0.002) {
        state.globeRotLat = state.globeTargetLat;
        state.globeRotLon = state.globeTargetLon;
        state.globeAnimating = false;
        renderGraph();
        return;
      }

      state.globeRotLat += deltaLat * 0.15;
      state.globeRotLon += deltaLon * 0.15;
      renderGraph();
      requestAnimationFrame(animateGlobe);
    }

    function angleDelta(target, current) {
      let delta = target - current;
      while (delta > Math.PI) delta -= Math.PI * 2;
      while (delta < -Math.PI) delta += Math.PI * 2;
      return delta;
    }

    function projectPoint(lat, lon) {
      const latR = (lat * Math.PI) / 180;
      const lonR = (lon * Math.PI) / 180;
      const x = Math.cos(latR) * Math.sin(lonR);
      const y = Math.sin(latR);
      const z = Math.cos(latR) * Math.cos(lonR);

      const cosY = Math.cos(state.globeRotLon);
      const sinY = Math.sin(state.globeRotLon);
      const x1 = x * cosY + z * sinY;
      const z1 = -x * sinY + z * cosY;

      const cosX = Math.cos(state.globeRotLat);
      const sinX = Math.sin(state.globeRotLat);
      const y1 = y * cosX - z1 * sinX;
      const z2 = y * sinX + z1 * cosX;

      return [x1, y1, z2];
    }

    function drawGraticule(cx, cy, radius) {
      ctx.strokeStyle = "#1a1f2a";
      ctx.lineWidth = 1;
      for (let lon = -150; lon < 180; lon += 30) {
        const points = [];
        for (let lat = -90; lat <= 90; lat += 6) {
          const [x, y, z] = projectPoint(lat, lon);
          if (z > 0) {
            points.push([cx + x * radius, cy - y * radius, true]);
          } else {
            points.push([0, 0, false]);
          }
        }
        drawVisibleLine(points);
      }

      for (let lat = -60; lat < 90; lat += 30) {
        const points = [];
        for (let lon = -180; lon <= 180; lon += 6) {
          const [x, y, z] = projectPoint(lat, lon);
          if (z > 0) {
            points.push([cx + x * radius, cy - y * radius, true]);
          } else {
            points.push([0, 0, false]);
          }
        }
        drawVisibleLine(points);
      }
    }

    function drawVisibleLine(points) {
      let segment = [];
      points.forEach(([px, py, visible]) => {
        if (visible) {
          segment.push([px, py]);
          return;
        }
        if (segment.length >= 2) {
          ctx.beginPath();
          ctx.moveTo(segment[0][0], segment[0][1]);
          segment.slice(1).forEach(([x, y]) => ctx.lineTo(x, y));
          ctx.stroke();
        }
        segment = [];
      });
      if (segment.length >= 2) {
        ctx.beginPath();
        ctx.moveTo(segment[0][0], segment[0][1]);
        segment.slice(1).forEach(([x, y]) => ctx.lineTo(x, y));
        ctx.stroke();
      }
    }

    graphCanvas.addEventListener("click", (event) => {
      const rect = graphCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      let closest = null;
      let closestDist = Infinity;
      Object.entries(state.screenPoints).forEach(([id, pos]) => {
        const dx = pos[0] - x;
        const dy = pos[1] - y;
        const dist = Math.hypot(dx, dy);
        if (dist < closestDist) {
          closestDist = dist;
          closest = id;
        }
      });
      if (closest && closestDist < 16) {
        selectRecord(closest);
        noteInteraction();
      }
    });

    function scheduleTour() {
      if (!state.tourEnabled || !state.order.length) return;
      clearTour();
      tourNote.textContent = "Default network tour will advance after a short pause.";
      state.tourTimer = window.setTimeout(() => {
        advanceTour();
      }, TOUR_DELAY_MS);
    }

    function clearTour() {
      if (state.tourTimer) {
        clearTimeout(state.tourTimer);
        state.tourTimer = null;
      }
    }

    function advanceTour() {
      if (!state.tourEnabled || !state.order.length) return;
      const order = state.order;
      let index = order.indexOf(state.selectedId);
      if (index < 0) index = 0;
      const nextId = order[(index + 1) % order.length];
      selectRecord(nextId, { fromTour: true });
      scheduleTour();
    }

    function noteInteraction() {
      if (!state.tourEnabled) return;
      scheduleTour();
    }

    function startAutoRefresh() {
      setInterval(() => {
        if (autoRefresh.checked) {
          loadDb();
        }
      }, REFRESH_MS);
    }

    window.mountEyeball("eyeball-terminology");
    window.mountEyeball("eyeball-foot");

    loadDb(true);
    startAutoRefresh();
  </script>
</body>
</html>
